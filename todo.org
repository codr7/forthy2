* allow postfix , for pairing
** add method
** emit id form in read_form if followed by ',' and != ','
** add pair tests
* --
* inherit macro from method
** add separate imp
** use dispatch for expand
* move cx.eval loop body into for
* add using PC = Node<Op>
** grep/replace
* reimplement read_int manually like read_frac
** keep hex support
* add MethodSet.nargs
** add constructor arg
** add test in add_method
** push first instead of set in id compile if !nargs
* add stack op methods
** .: dup
** :. drop 
** :: swap
** extract bool id_char(char) from read_id
** return DotForm if followed by id_char()
* inherit Form from Val
** add Form type to cx/abc
* add support for arg index
** add Arg.index/index_id + constructor
** dump as ,foo Int
** method =(,t A t)
** add map<id, index> to Args
** perform separate pass to get indexes
** get parent type from stack by index in Method.applicable()
* add scope support for ;
** compile as separate scope
* add static array of Int[100]
** override int_type.get
* --
* add int math ops
* add ref-support
** &foo
** IdForm or "Invalid ref: "
** add RefForm
** resolve at compile time
* add |-support for values
** eval on compile stack in Lit.compile if cte
* add else macro
* add method macro
** clone env on compile
** compile body with_env on first use
* add isa/type-of methods
* add stack literals
** (1 2 3; 4 5)
** parse suffix as separate stack
* unlink existing method if exists in MethodSet.push
* add nil type
** Int?
** add nil type / _
** add Type *Type.or_nil()
*** return this if opt
* add quote
** '(1 2 3) 'foo
* add C++ emit
** add -build mode
** use label/goto
