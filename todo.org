* add method macro
** compile body with_env
** init Method.fn
** finish Method.call()
* rewrite fib_rec-if using literal method args
* --
* add MethodSet.nargs
** add constructor arg
** add test in add_method
** push first instead of set in id compile if !nargs
* emit safe call in id compile if method set len is 1
* switch Type.parents to sorted vector like env
* add static array of Int vals
** add MAX_FAST_INT
* --
* add recall method
** goto beg_pc
** optional arg for target
*** update cx.call.beg_pc if specified
* add fib_tail
* --
* add fib_iter
* --
* add fix point readme
* add next-method fun
** search call-chain for method call
*** return next from method.set
**** _ if missing
* add |-support for values
** eval in Lit.compile if cte
** check readme example
* add for macro
** add Type.iter method with callback
* add stack lib
** move existing ops
** import in main
** add copy(Stack? n offs), clone(Stack? n offs), swap(Stack? x y) & drop(Stack? n offs) methods
*** add backing Stack methods
** make stack arg to push/pop/len optional
** add peek with offs
* add stash/splat
** stash (..)
** splat foo..
* add stack interpolation
** (1 3 5 (%{+})) -> (1 (8))
* implement MethodSet.clone
** switch to use vector/upper_bound like env
*** drop method Node
* inherit macro from method
** add separate imp
** use dispatch for expand
* reimplement read_int manually like read_frac
** keep hex support
* add switch
** use branch op
*** pop_if = true
** add jump op
* add Byte type
** Imp = uint8_t
** read hex as byte if < 256
** add int/byte conversions
* add Char type
** cidk
** add reader support
*** \r \n \t \s \e
*** \0x2a \90 \\A \\a \\\
** add conversion to/from int/byte
* add quote
** '(1 2 3) 'foo
* add string type
* add say method
** add val.print
*** default to dump
*** print symbols with quote
*** print stack items in sequence
*** print pair items separated by space
* add C++ emit
** add -build mode
** use label/goto
